from django.shortcuts import render
from rest_framework import generics, status
from django.http import HttpResponse, JsonResponse
from rest_framework.permissions import AllowAny
import requests
import zipfile
import os
import json
import pefile
import csv
import math
from .basic_script import runme
from .predictSPIT import pred
import pandas as pd
import numpy as np

# Create your views here.


def get_entropy(pe_path):
    entropy = 0
    for count in byte_counts:
        # If no bytes of this value were seen in the value, it doesn't affect
        # the entropy of the file.
        if count == 0:
            continue
        # p is the probability of seeing this byte in the file, as a floating-
        # point number
        p = 1.0 * count / total
        entropy -= p * math.log(p, 256)


def make_PE_csv(pe_path):
    pe = pefile.PE(pe_path)

    with open('CSV/temp.csv', 'w') as file:
        writer = csv.writer(file)
        writer.writerow([
            'BaseOfCode',
            'BaseOfData',
            'Characteristics',
            'DllCharacteristics',
            'Entropy',
            'FileAlignment',
            # 'FirstSeenDate',
            # 'Identify',
            'ImageBase',
            'ImportedDlls',
            'ImportedSymbols',
            # 'Label',
            'Machine',
            'Magic',
            'NumberOfRvaAndSizes',
            'NumberOfSections',
            'NumberOfSymbols',
            # 'PE_TYPE',
            'PointerToSymbolTable',
            # 'SHA1',
            'Size',
            'SizeOfCode',
            'SizeOfHeaders',
            'SizeOfImage',
            'SizeOfInitializedData',
            'SizeOfOptionalHeader',
            'SizeOfUninitializedData',
            'TimeDateStamp'
        ])

        DLLs = []
        symbols = []
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            DLLs.append(entry.dll.decode('utf-8'))
            for imp in entry.imports:
                symbols.append(imp.name.decode('utf-8'))
        imp_dll = ' '.join(DLLs)
        imp_symbols = ' '.join(symbols)

        writer.writerow([
            int(pe.OPTIONAL_HEADER.BaseOfCode),
            int(pe.OPTIONAL_HEADER.BaseOfData),
            int(pe.FILE_HEADER.Characteristics),
            int(pe.OPTIONAL_HEADER.DllCharacteristics),
            6.694522,
            int(pe.OPTIONAL_HEADER.FileAlignment),
            int(pe.OPTIONAL_HEADER.ImageBase),
            imp_dll,
            imp_symbols,
            int(pe.FILE_HEADER.Machine),
            int(pe.OPTIONAL_HEADER.Magic),
            int(pe.OPTIONAL_HEADER.NumberOfRvaAndSizes),
            int(pe.FILE_HEADER.NumberOfSections),
            int(pe.FILE_HEADER.NumberOfSymbols),
            int(pe.FILE_HEADER.PointerToSymbolTable),
            6895724,
            int(pe.OPTIONAL_HEADER.SizeOfCode),
            int(pe.OPTIONAL_HEADER.SizeOfHeaders),
            int(pe.OPTIONAL_HEADER.SizeOfImage),
            int(pe.OPTIONAL_HEADER.SizeOfInitializedData),
            int(pe.FILE_HEADER.SizeOfOptionalHeader),
            int(pe.OPTIONAL_HEADER.SizeOfUninitializedData),
            int(pe.FILE_HEADER.TimeDateStamp),
        ])

        file.save()

    f_Path = "/home/beastmode/Desktop/DJSCE/Hackathons/SPIT/CSV/temp.csv"
    df = pd.read_csv('final.csv')
    df1 = pd.read_csv(f_Path)  #for test2.csv
    df1.drop(['SizeOfOptionalHeader', 'Magic'], axis=1, inplace=True)
    for i in range(len(df1)):
        df1['ImportedDlls'][i] = df1['ImportedDlls'][i].split()
    df_concat = pd.DataFrame(index=[i for i in range(len(df1))],
                             columns=list(df.columns))
    rem_list = list(df1.columns)
    rem_list.remove('ImportedDlls')
    rem_list.remove('ImportedSymbols')
    df_concat.drop(rem_list, axis=1, inplace=True)
    df_concat.drop(['Label'], axis=1, inplace=True)
    fr = []
    for i in range(len(list(df_concat.columns))):
        fr.append(0)
    for i in range(len(df1)):
        df_concat.iloc[i] = fr
    for j in range(len(df1)):
        for i in range(len(list(df_concat.columns))):
            if list(df_concat.columns)[i] in df1['ImportedDlls'][j]:
                df_concat.iat[j, i] = 1
    df1.drop(['ImportedDlls', 'ImportedSymbols'], axis=1, inplace=True)
    df3 = pd.concat([df1, df_concat], axis=1)
    df3.drop('Unnamed: 0', axis=1, inplace=True)
    return pred(df3)


class DetectMalware(generics.GenericAPIView):
    permission_classes = (AllowAny, )

    def post(self, request):
        try:
            form_data = json.loads(request.body.decode())
            link = form_data['link']
        except Exception:
            link = request.POST.get('link')

        header = requests.head(link, allow_redirects=True).headers
        ftype = header.get('content-type')
        if header.get('content-disposition') and 'filename' in header.get(
                'content-disposition'):
            filename = header.get('content-disposition').split('filename=')[-1]
            ext = filename[-3:]
        elif link.split('/')[-1][-4] == '.':
            filename = link.split('/')[-1]
            ext = filename[-3:]
        else:
            filename = None
            ext = None

        if (
                ext and (ext == 'exe' or ext == 'dll')
        ) or (ftype in
              'application/octet-stream, application/x-msdownload, application/exe, application/x-exe, application/dos-exe, vms/exe, application/x-winexe, application/msdos-windows, application/x-msdos-program'
              ):
            r = requests.get(link, allow_redirects=True)
            with open("downloads/" + filename, 'wb') as f:
                f.write(r.content)
            score = make_PE_csv("downloads/" + filename)

            return JsonResponse({'success': "success", "score": score})

        elif (ext and ext == 'zip') or (ftype == 'application/x-msdownload'):
            r = requests.get(link, allow_redirects=True)
            with open("downloads/" + filename, 'wb') as f:
                f.write(r.content)
            with zipfile.ZipFile("downloads/" + filename, 'r') as zip_ref:
                zip_ref.extractall("downloads/" + filename[:-4])

            for file in os.listdir("downloads/" + filename[:-4]):
                if file.endswith(".exe") or file.endswith(".dll"):
                    score = make_PE_csv("downloads/" + filename[:-4] + '/' +
                                        file)
                return JsonResponse({'success': "success", "score": score})

        else:
            return JsonResponse({'success': "wrong file type.", "score": None})
